<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>3D Hand Interaction Particles</title>
    
    <!-- MediaPipe Dependencies -->
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/control_utils/control_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/drawing_utils/drawing_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/hands/hands.js" crossorigin="anonymous"></script>

    <style>
        body { margin: 0; overflow: hidden; background-color: #050505; font-family: 'Segoe UI', sans-serif; color: white; }
        canvas { display: block; }
        
        /* UI Overlay */
        #ui-container {
            position: absolute;
            top: 20px;
            left: 20px;
            width: 280px;
            background: rgba(20, 20, 20, 0.85);
            padding: 20px;
            border-radius: 12px;
            border: 1px solid #444;
            backdrop-filter: blur(5px);
            z-index: 10;
            user-select: none;
        }

        h2 { margin: 0 0 15px 0; font-size: 1.2rem; text-transform: uppercase; letter-spacing: 1px; color: #00d2ff; }
        
        .control-group { margin-bottom: 15px; }
        label { display: block; font-size: 0.85rem; margin-bottom: 5px; color: #ccc; }
        input[type="range"] { width: 100%; cursor: pointer; accent-color: #00d2ff; }
        
        .btn-group { display: grid; grid-template-columns: 1fr 1fr; gap: 8px; }
        button {
            background: #333;
            border: 1px solid #555;
            color: white;
            padding: 8px;
            cursor: pointer;
            border-radius: 4px;
            transition: all 0.2s;
            font-size: 0.8rem;
        }
        button:hover { background: #444; border-color: #00d2ff; }
        button.active { background: #00d2ff; color: #000; font-weight: bold; border-color: #00d2ff; }

        #status {
            margin-top: 15px;
            font-size: 0.8rem;
            color: #888;
            border-top: 1px solid #444;
            padding-top: 10px;
        }
        
        /* Hide the video element used for tracking */
        .input_video { display: none; }
    </style>
</head>
<body>

    <!-- Video element for MediaPipe (Hidden) -->
    <video class="input_video"></video>

    <!-- UI Panel -->
    <div id="ui-container">
        <h2>Particle Controller</h2>
        
        <div class="control-group">
            <label>Shape Selection</label>
            <div class="btn-group">
                <button onclick="setShape('sphere')" class="active" id="btn-sphere">Sphere</button>
                <button onclick="setShape('cube')" id="btn-cube">Cube</button>
                <button onclick="setShape('heart')" id="btn-heart">Heart</button>
                <button onclick="setShape('spiral')" id="btn-spiral">Spiral</button>
            </div>
        </div>

        <div class="control-group">
            <label for="pCount">Count (<span id="countVal">20000</span>)</label>
            <input type="range" id="pCount" min="1000" max="40000" value="20000" step="1000">
        </div>

        <div class="control-group">
            <label for="forceStr">Interaction Force</label>
            <input type="range" id="forceStr" min="0.1" max="5.0" value="2.0" step="0.1">
        </div>

        <div class="control-group">
            <label for="radiusSize">Shape Scale</label>
            <input type="range" id="radiusSize" min="1" max="10" value="5" step="0.1">
        </div>

        <div id="status">
            Hand: <span id="handStatus" style="color: #666;">Not Detected</span><br>
            Gesture: <span id="gestureStatus" style="color: #666;">-</span>
        </div>
    </div>

    <!-- Main Logic -->
    <script type="module">
        import * as THREE from 'https://unpkg.com/three@0.160.0/build/three.module.js';

        // --- Configuration ---
        const config = {
            particleCount: 20000,
            maxParticleCount: 40000,
            shapeScale: 5,
            interactionForce: 2.0,
            returnSpeed: 0.08,
            damping: 0.92,
            interactionRadius: 6,
            currentColor: new THREE.Color(0x00d2ff)
        };

        // --- Global State ---
        let scene, camera, renderer;
        let particles, geometry, material;
        let positions, targets, velocities; // Float32Arrays
        let handPosition = new THREE.Vector3(9999, 9999, 9999); // Off-screen default
        let isHandPresent = false;
        let gestureMode = 0; // 0 = None, 1 = Repel (Open), -1 = Attract (Fist)
        
        // --- Initialization ---
        function init() {
            // 1. Scene Setup
            scene = new THREE.Scene();
            scene.fog = new THREE.FogExp2(0x050505, 0.02);

            camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
            camera.position.z = 25;

            renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
            document.body.appendChild(renderer.domElement);

            // 2. Particle System Setup
            geometry = new THREE.BufferGeometry();
            
            // Allocate memory for max particles
            positions = new Float32Array(config.maxParticleCount * 3);
            targets = new Float32Array(config.maxParticleCount * 3);
            velocities = new Float32Array(config.maxParticleCount * 3);

            geometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
            
            // Texture for particle
            const sprite = new THREE.TextureLoader().load('https://threejs.org/examples/textures/sprites/disc.png');

            material = new THREE.PointsMaterial({
                color: 0xffffff,
                size: 0.25,
                map: sprite,
                transparent: true,
                opacity: 0.8,
                blending: THREE.AdditiveBlending,
                depthWrite: false,
                vertexColors: false
            });
            material.color = config.currentColor;

            particles = new THREE.Points(geometry, material);
            scene.add(particles);

            // Initial Shape
            generateShape('sphere');

            // Listeners
            window.addEventListener('resize', onWindowResize);
            setupUI();
            
            // Start Loop
            animate();
        }

        // --- Physics & Animation ---
        function animate() {
            requestAnimationFrame(animate);

            const count = config.particleCount;
            const positionsAttr = geometry.attributes.position;
            const pArr = positionsAttr.array;
            
            const forceVal = config.interactionForce * 0.2; // Scaling factor
            const returnSpd = config.returnSpeed;
            const damp = config.damping;
            const radiusSq = config.interactionRadius * config.interactionRadius;

            // Hand World Position
            const hx = handPosition.x;
            const hy = handPosition.y;
            const hz = handPosition.z;

            for (let i = 0; i < count; i++) {
                const ix = i * 3;
                const iy = i * 3 + 1;
                const iz = i * 3 + 2;

                // 1. Calculate vector to home (Target - Current)
                const tx = targets[ix];
                const ty = targets[iy];
                const tz = targets[iz];

                const px = pArr[ix];
                const py = pArr[iy];
                const pz = pArr[iz];

                // Spring force to return home
                let ax = (tx - px) * returnSpd;
                let ay = (ty - py) * returnSpd;
                let az = (tz - pz) * returnSpd;

                // 2. Hand Interaction
                if (isHandPresent) {
                    const dx = px - hx;
                    const dy = py - hy;
                    const dz = pz - hz;
                    const distSq = dx*dx + dy*dy + dz*dz;

                    if (distSq < 100) { // Interaction range
                        const dist = Math.sqrt(distSq);
                        const f = (10 - dist) * forceVal; // Falloff
                        
                        // Gesture Mode: 1 = Push (Repel), -1 = Pull (Attract)
                        if (gestureMode !== 0) {
                            const dir = gestureMode; // 1 or -1
                            
                            // Normalized direction * force
                            if (dist > 0.1) {
                                ax += (dx / dist) * f * dir;
                                ay += (dy / dist) * f * dir;
                                az += (dz / dist) * f * dir;
                            }
                        }
                        // If gestureMode is 0 (neutral hand), we don't apply extra force, 
                        // or we could add a slight turbulence. 
                    }
                }

                // 3. Update Velocity & Position
                velocities[ix] += ax;
                velocities[iy] += ay;
                velocities[iz] += az;

                velocities[ix] *= damp;
                velocities[iy] *= damp;
                velocities[iz] *= damp;

                pArr[ix] += velocities[ix];
                pArr[iy] += velocities[iy];
                pArr[iz] += velocities[iz];
            }

            positionsAttr.needsUpdate = true;
            
            // Slow rotation of the whole system for aesthetics
            particles.rotation.y += 0.001;

            renderer.render(scene, camera);
        }

        // --- Shape Generators ---
        function generateShape(type) {
            const count = config.maxParticleCount;
            const scale = config.shapeScale;

            for (let i = 0; i < count; i++) {
                const i3 = i * 3;
                let x, y, z;

                if (type === 'cube') {
                    x = (Math.random() - 0.5) * 2 * scale;
                    y = (Math.random() - 0.5) * 2 * scale;
                    z = (Math.random() - 0.5) * 2 * scale;
                } 
                else if (type === 'sphere') {
                    const r = scale * Math.cbrt(Math.random());
                    const theta = Math.random() * 2 * Math.PI;
                    const phi = Math.acos(2 * Math.random() - 1);
                    x = r * Math.sin(phi) * Math.cos(theta);
                    y = r * Math.sin(phi) * Math.sin(theta);
                    z = r * Math.cos(phi);
                } 
                else if (type === 'spiral') {
                    const t = i / count * 20 * Math.PI;
                    const r = (i / count) * scale;
                    x = r * Math.cos(t);
                    y = (Math.random() - 0.5) * scale * 2; // Cylinder scatter
                    z = r * Math.sin(t);
                }
                else if (type === 'heart') {
                    // Parametric Heart
                    // Randomize t to spread points
                    const t = Math.random() * Math.PI * 2;
                    // Spread inside volume
                    const r = scale * Math.sqrt(Math.random()) * 0.5; 
                    
                    // Heart equation
                    const hx = 16 * Math.pow(Math.sin(t), 3);
                    const hy = 13 * Math.cos(t) - 5 * Math.cos(2*t) - 2 * Math.cos(3*t) - Math.cos(4*t);
                    
                    x = hx * (r/5); // Scale down fit
                    y = hy * (r/5);
                    z = (Math.random() - 0.5) * scale;
                }

                targets[i3] = x;
                targets[i3 + 1] = y;
                targets[i3 + 2] = z;
            }
        }

        // --- UI Logic ---
        function setupUI() {
            const countSlider = document.getElementById('pCount');
            const forceSlider = document.getElementById('forceStr');
            const radiusSlider = document.getElementById('radiusSize');
            const countDisplay = document.getElementById('countVal');

            countSlider.addEventListener('input', (e) => {
                config.particleCount = parseInt(e.target.value);
                geometry.setDrawRange(0, config.particleCount);
                countDisplay.innerText = config.particleCount;
            });

            forceSlider.addEventListener('input', (e) => {
                config.interactionForce = parseFloat(e.target.value);
            });

            radiusSlider.addEventListener('input', (e) => {
                config.shapeScale = parseFloat(e.target.value);
                // Regenerate current shape with new scale
                const activeBtn = document.querySelector('.btn-group button.active');
                if(activeBtn) generateShape(activeBtn.innerText.toLowerCase());
            });

            // Geometry Draw Range init
            geometry.setDrawRange(0, config.particleCount);
        }

        // Expose shape setter to global scope for HTML buttons
        window.setShape = function(shape) {
            generateShape(shape);
            
            // UI Styling
            document.querySelectorAll('.btn-group button').forEach(b => b.classList.remove('active'));
            document.getElementById('btn-' + shape).classList.add('active');
            
            // Color Shift based on shape
            if(shape === 'heart') config.currentColor.setHex(0xff0055);
            else if(shape === 'cube') config.currentColor.setHex(0x00ff88);
            else if(shape === 'spiral') config.currentColor.setHex(0xffaa00);
            else config.currentColor.setHex(0x00d2ff); // Sphere
            
            material.color = config.currentColor;
        };

        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        }

        // --- MediaPipe Logic ---
        
        const videoElement = document.getElementsByClassName('input_video')[0];
        const handStatus = document.getElementById('handStatus');
        const gestureStatus = document.getElementById('gestureStatus');

        function onResults(results) {
            if (results.multiHandLandmarks && results.multiHandLandmarks.length > 0) {
                isHandPresent = true;
                const landmarks = results.multiHandLandmarks[0];

                // 1. Map Coordinates (0-1) to Three.js World Space
                // Note: Webcam is mirrored, so we invert X relative to calculation
                // Simple orthogonal projection mapping
                const aspect = window.innerWidth / window.innerHeight;
                const viewSize = 25; // Approximate Z depth
                
                // Using Index Finger Tip (8) or Palm Center (9)
                const palmX = landmarks[9].x;
                const palmY = landmarks[9].y;
                
                // Convert to -1 to 1 space then scale to world
                const ndcX = (1.0 - palmX) * 2 - 1; // Flip X for mirror feel
                const ndcY = -(palmY * 2 - 1);      // Flip Y because canvas Y is up
                
                // Unproject logic simplified for performance
                // Assume hand is at z=0 plane roughly
                const vec = new THREE.Vector3(ndcX, ndcY, 0.5);
                vec.unproject(camera);
                const dir = vec.sub(camera.position).normalize();
                const distance = -camera.position.z / dir.z; // Project to Z=0
                const pos = camera.position.clone().add(dir.multiplyScalar(distance));
                
                handPosition.set(pos.x, pos.y, pos.z);

                // 2. Gesture Recognition (Open vs Fist)
                // Calculate average distance of fingertips to wrist
                const wrist = landmarks[0];
                const tips = [8, 12, 16, 20]; // Finger tips
                let avgDist = 0;
                
                tips.forEach(idx => {
                    const d = Math.sqrt(
                        Math.pow(landmarks[idx].x - wrist.x, 2) + 
                        Math.pow(landmarks[idx].y - wrist.y, 2)
                    );
                    avgDist += d;
                });
                avgDist /= tips.length;

                // Thresholds usually around 0.2 - 0.4 depending on hand distance
                // Heuristic: If fingers are curled, distance to wrist is small.
                
                if (avgDist < 0.25) {
                    gestureMode = -1; // FIST -> PULL
                    handStatus.innerText = "Detected";
                    handStatus.style.color = "#00ff00";
                    gestureStatus.innerText = "Fist (Pull)";
                    gestureStatus.style.color = "#ffaa00";
                    document.body.style.cursor = 'crosshair';
                } else {
                    gestureMode = 1; // OPEN -> PUSH
                    handStatus.innerText = "Detected";
                    handStatus.style.color = "#00ff00";
                    gestureStatus.innerText = "Open (Push)";
                    gestureStatus.style.color = "#00d2ff";
                    document.body.style.cursor = 'grab';
                }

            } else {
                isHandPresent = false;
                handPosition.set(9999, 9999, 9999);
                gestureMode = 0;
                handStatus.innerText = "Not Detected";
                handStatus.style.color = "#666";
                gestureStatus.innerText = "-";
                document.body.style.cursor = 'default';
            }
        }

        // Initialize MediaPipe Hands
        const hands = new Hands({locateFile: (file) => {
            return `https://cdn.jsdelivr.net/npm/@mediapipe/hands/${file}`;
        }});

        hands.setOptions({
            maxNumHands: 1,
            modelComplexity: 1,
            minDetectionConfidence: 0.5,
            minTrackingConfidence: 0.5
        });

        hands.onResults(onResults);

        // Initialize Camera
        const cameraUtils = new Camera(videoElement, {
            onFrame: async () => {
                await hands.send({image: videoElement});
            },
            width: 640,
            height: 480
        });
        
        // Boot everything
        init();
        cameraUtils.start();

    </script>
</body>
</html>